开始我们的最后一本书《鸟哥的Linux私房菜》了，这本书由于过于扎实，与导师商量后决定不重要的部分就快速过一遍

该笔记根据章节分开记录

## 第0章 计算机概论

1. **外频**是计算机与外部组件进行数据传输时的速度，**倍频**是CPU内部用来加速内部性能的倍数，**两者相乘**即为CPU的频率速度

## 第1章 Linux是什么和如何学习

这章Linux历史居多，很多general的东西，没笔记

## 第2章 主机规划和磁盘分区

1. 扇区和磁道：这部分太老掉牙了，现在都是SSD，《Operation System》 3rd-ver还有专门几个小节讲，4th-ver就已经完全删去这部分内容了
2. 分区有利于把数据集中在部分扇区，加快查找速度；还有就是保障安全性
3. 分区有以下特性：
   1. 主引导记录（MBR）：安装启动程序的地方，有446字节
   2. 分区表：记录整块硬盘分区的状态，有64字节，最多四组记录，每组都记录了开始和结束的柱面号码。这四组信息被称为主要（primary）或扩展（extended）分区
   3. 所谓的分区就只是对64字节的分区表进行设置而已
   4. 扩展分区是分布在每个分区的最前面几个扇区来记录分区信息，本身并不能用来初始化，最多只能有一个，从extended分区还能划分出逻辑分区，逻辑分区和主要分区都能被格式化
   5. 逻辑分区sda从5开始，sda1~sda4是分配给primary或extended分区用的（多年的疑惑）
   6. 如果要**划定四个以上**的分区一定要有扩展分区。且考虑到磁盘的连续性，一般建议将扩展分区的柱面号码分配到最后面的柱面内
4. 启动流程中的BIOS与UFEI启动检测程序（面试问题）
   1. BIOS是写入主板的一个固件，BIO是计算机系统会主动执行的第一个程序
   2. 之后BIOS会到硬盘中读取**第一个扇区**的MBR位置，MBR 446字节的容量里放着基本的启动引导程序（boot loader）
   3. 这个boot loader是os安装时提供的，认识硬盘内的文件系统，因而可以读取内核文件，其任务：提供用户选择的启动选项，加载内核文件，或转交其他引导程序（引导程序可安装在每个分区的启动扇区，双系统的本质P77）
5. UFEI BIOS搭配GPT启动
   1. GPT可以通过64位寻址，也能提供较大的区块处理启动程序，但BIOS是一个16位程序，无法理解GPT，因此有了UFEI
   2. P78图，UFEI BIOS与BIOS的对比
   3. UFEI用polling处理硬件，BIOS用CPU中断，所以其实UFEI效率会低一些
   4. UFEI加入了secure boot的功能，防止hacker用BIOS启动阶段来破坏系统

## 第3章 安装CentOS 7.x

这里因为我一直都是用的ubuntu，而且在读到这部分时已经完成了ubuntu16虚拟机以及最终项目基础demo的运行，所以这部分就不看了

## 第4章 首次登录与在线求助

 这章主要是跟着做的

1. terminal命令的执行：
   1. 第一个被输入的字符**一定是命令或可执行文件**
   2. bc进入计算器，默认只有整型计算，小数点都被截掉，通过`scale=number`，number来决定保留几位小数
   3. 之前只用过`cd D[tab][tab]`来显示匹配的文件名，还可以直接`ca[tab][tab]`来显示符合前缀的命令
   4. `ctrl+d`可以退出命令行模式，可代替exit
   5. `[shift]+{[PageUp][PageDown]}`来上下翻看terminal页面信息
   6. `man+[command]`会显示这个command的详细信息，注意`[command(number)]`，这个number是有意义的，可以在P136查表。在man page可以通过`/+[string]`来匹配文本中的字符串
   7. `info`是由node组织的，进入node后的操作可在P141查到，也可以像man一样查到command的详细信息
2. nano指令（这个就不多说了，我比起vim更喜欢用nano）
3. `shutdown -h time`表示定时关机，-r表示reboot

## 第5章 linux权限和目录配置

用户组的概念其实在AWS以及Github中的配置中也有，大家思想都是类似的这里不赘述

1. `ls -al`的读写权限的解析（P153），如`drwxrw-r--`
   1. 第一个字符[d]表示这是一个directory，如果是文件则为[-]，[l]表示为链接文件，[b]表示设备里可供存储的周边设备，[c]表示为串行设备（如键盘，鼠标）
   2. 之后的都是三个字符一组，[r]是read，[w]是write，[x]是可执行
   3. 后面三组分别代表了**文件拥有者权限**，**加入此用户组账号权限**，**未加入用户组人的权限**
2. `chgrp`和`chown`分别是change group和change owner（P156），不是经常用到，所以主要讲`chmod`，因为就像上面提到的，权限三个一组，所以`7->111->rwx`，其他的以此类推，也就有了天天用的`chmod 777 file`这样的语句
3. 一个有意思的事：如果用户组没read权限，ls指令都会被permission denied，然后试了一下root下把文件chmod 000之后ls，发现其实root还是能看见的
4. 一般要读到directory底下的文件，都要拥有这个directory的`r-x`权限，r只是决定[tab]能否补全，x才是关键，决定能否打开
5. 文件种类和扩展名（这里只列举不算熟悉的，P163详细版本）：
   1. 常规文件：
      1. 纯文本文件（ASCII）：`cat`指令可以把文件内容读出来，ASCII文件可以被cat读出来
      2. 二进制文件（.bin）：一种可执行文件，`cat`自己就是一个二进制文件
      3. 数据文件（data）：可以使用`last`指令读出来，`cat`会读成乱码
   2. 链接文件[l]：类似于win下的快捷方式
   3. 数据接口（sockets，[s]）

## 第6章 Linux文件与目录管理

1. `pwd`（print working directory）显示当前文件夹，`cd -`返回刚刚的目录

2. `echo $PATH`打印执行文件路径的原理：`echo`就是显示，打印；$后跟变量

3. cp的copy过程默认源文件和目标文件的权限不同，目标文件的权限**是命令者自身的权限**，如果想要连同文件权限全盘copy，使用`cp -a [source dir] [target dir]`

4. `cp -l`和`cp -s`都会建立链接文件（link file），-l是hard链接，-s是symbol链接（有->指向链接文件，不增加源文件的link数量）

5. `rm -[fir]`：-f是force，强制删除；-i是interact，交互模式，会一个个询问是否删除；-r递归删除，十分危险（我经常用来删dir...）

6. `mv -[fiu]`：-f同样是force，如果重复了就直接覆盖；-i就是一个个询问是否覆盖；-u就是update，如果source比较新就会把原本的update。注意如果mv多个文件或目录，那么最后一个一定是目标目录

7. 文件内容查看
   1. tac从最后一行开始显示，是cat的倒写
   2. nl显示的时候，同时显示行号
   3. more一page一page地显示文件内容
   4. less和more类似，但可以向前翻页
   5. head/tail只看前/后几行（-n 表示行数）
      1. head可用-n -100表示忽略后面一百行，把100行前面的都打出来
      2. tail可用-n +100表示忽略前一百行，把100行后面的都打出来
   6. od以二进制形式读文件（读入二进制，-t决定以什么形式输出）
   
8. `touch [-acdmt] 文件`，如果文件存在，那么该文件的三个时间（atime(access time), ctime, mtime(modified time)）都被更新为当前时间（我一般都是不存在直接生成文件用的touch...）

9. 文件的默认权限可以使用`umask`查看，umask给出的例如`0002`结果，是后三位有效，该例中使用`umask -S`看到的真实默认权限为`u=rwx,g=rwx,o=rx`，能看出来其实就是掩码

   1. `chattr [+-=][ASacdistu]`（change attribute）可以配置文件隐藏特性，这里只介绍俩：`a`设置之后，文件**只能增加**不能删除或修改；`i`可以让一个文件**不能被删除，改名，设置link，也无法写入或增加数据**（甚至`rm -f`都删不掉）。这俩都是要root权限
   2. 可以用`lsattr`（list attribute）来看这些被设置的隐藏属性

10. 文件特殊权限：SUID, SGID, SBIT

    1. Set UID

       当s这个标志出现在owner的x权限的位置上时（`ls -l /usr/bin/passwd`可以看到），就被称为SUID，有以下限制和功能：

       1. 仅对binary程序有效（不能用在shell脚本或目录上）
       2. 执行者对于该程序需要有x的权限（比如执行者和passwd的关系）
       3. 本权限仅在执行过程中有效
       4. 执行者将具有**该程序**的owner权限（passwd的owner权限）

       书上P198给了一个例子，这就好比使用passwd命令可以让用户暂时获得passwd的owner的权限，并支持在程序执行期间对其他文件（书上的shadow文件，原本权限是`----------`）进行passwd的owner权限级别的修改

    2. Set GID

       当s这个标志出现在group的x权限的位置上时（书上说`ls -l /usr/bin/locate`可以看到，但ubuntu16上并没有），就被称为SGID，有以下功能：

       1. SGID对binary程序有用
       2. 执行者对于该程序需要具备x权限
       3. 执行者在执行过程中获得**该程序**的group支持（这里对应的是把执行者转换为目标文件的用户组，而不是passwd的group权限）

       基本上和SUID同理

    3. Sticky Bit

       可通过`ls -l /tmp`看到带t的权限，虚拟机里是`VMwareDnD`

       1. 只针对目录有效
       2. 当用户对于此目录有w，x的权限时，有写入能力
       3. 当用户在此目录下建立文件或目录时，**仅有自己和root**才有权力**删除**该文件

       说白了就是有w和x的话，谁都可以写，但是一旦写了就只有写的人以及root可以删除

    4. 可以在原本的三个数字的权限前加上一个数字，就表示以上三种特殊权限。

       1. 4为SUID
       2. 2为SGID
       3. 1为SBIT

       比如把权限改为`-rwsr-xr-x`时，可用`chmod 4755 filename`来实现

11. `which [-a] command`可以使用`which`来找到command的执行文件放在哪里，`-a`会把PATH目录里所有找到的命令都列出来而不是只列出一个

12. 一般都是先用`whereis`和`locate`来找文件，因为`whereis`只在限定的目录下找，而`locate`是在mlocate的数据库里找，所以快；找不到再用`find`，`find`可根据时间，权限，使用者，大小等查找P203

## 第7章 Linux磁盘与文件系统管理

1. 一个可挂载的数据为一个文件系统而非一个分区，通常把**文件权限（rwx）和文件属性（拥有者，用户组，时间参数）**与数据分开放置。权限和属性放在inode中，数据放在数据区块里

   1. superblock超级区块：记录此系统的整体信息，包括inode与数据区块的总量，使用量，格式等信息
   2. inode：记录文件属性，一个文件占用一个inode，同时记录此文件数据所在的区块号码
   3. 数据区块：实际记录文件内容，一个大文件可占用多个区块

2. 索引式文件系统参见P212图，这种系统会有inode去记录具体的区块，非索引式如FAT需要把所有的磁盘读出来（顺序读取和hashmap的区别），因此需要时不时碎片整理

3. ext2是一种索引式文件系统，支持的区块有1K, 2K, 4K三种：

   1. 区块的大小和数量在格式化后不能更改，除非重新格式化
   2. 每个区块内最多放置一个文件的数据
   3. 但一个文件可占用多个区块
   4. 如果一个文件大小小于区块大小，那么就会浪费磁盘空间

4. inode表记录的信息见P213，就是权限，时间，使用者，大小，block等

5. superblock（超级块）记录：

   1. 数据区块与inode总量
   2. 未使用和已使用的block以及inode数量
   3. block和inode大小（block 1k,2k,4k；inode128B, 256B）
   4. 文件系统挂载时间，最近一次写入数据时间，最近一次检验磁盘（fsck）时间等信息
   5. 一个有效位，0已被挂载，1未被挂载

   可以使用`dumpe2fs`来查询（dump ext2 file system，用过了，很详细）

6. 因为可能出现数据不一致的问题，所以又出现了**日志式文件系统**，原本不一致时check超级块中的有效位和文件状态，日志式只要看日志记录的区块就可以了，快很多

7. Linux把常用文件数据放进内存的cache buffer，可以使用`sync`强制把dirty数据写入磁盘（正常关机时，系统就调用这个命令）

8. 将文件系统和目录树结合的操作称为挂载，**挂载点一定是目录**，是进入该文件系统的入口（以前双系统扩容用到过）

9. `df`(display filesystem)看整个文件系统的磁盘使用（block版本，可以用`df -h`看正常占用版本），`du`看文件系统的磁盘使用（常用于看目录）

10. 所以前面讲了这么多，终于说到了硬链接（hard link），本质就是在某个目录下**新增一个文件名链接到inode**（类似传指针，即使源文件被删了，也能通过链接文件找到数据），不能跨文件系统，不能链接目录（消耗过大，不支持），不占用额外区块

11. 相应的，符号链接（symbolic link）就像是快捷方式，一旦源文件被删，那么就找不到了。是独立的文件，会占用inode和区块

12. `ln [-sf] sourcefile targetfile`，如果不加参数默认硬链接，`-s`就是符号链接，`-f`如果目标文件存在就直接删了再建立

13. 每个新的目录会有2链接，一个是`/tmp/testing也叫/tmp/testing/.`，另一个是返回上级目录`tmp/testing/..`，如果新建了一个目录，比如新建`/tmp/testing`，那么`/tmp`目录的链接数量也会+1

14. `lsblk`（list block device），看以看到所有磁盘和磁盘内的分区信息，具体见P232

15. `blkid`（block id）列出设备的UUID，`parted device_name print`可以列出磁盘的分区表类型和分区信息

16. 用`gdisk`可以处理分区（P235），但新增分区使用w写入后，重新启动才有效，但可以通过`partprobe`来更新分区信息

17. `mkfs`是创建文件系统，也是通常说的格式化（P238）

18. `fsck.ext4`可以对ext4文件系统进行检查，但注意必须是在文件系统有问题时使用该命令，被检查的硬盘分区务必**不可挂载到系统上**，即需要在卸载的状态

19. `mount`挂载（P243），启动挂载（P248）

20. 内存交换区[swap]，以前内存不足时，可以将内存中的数据暂时放到硬盘中，这部分硬盘就是内存交换区。（P252，ubuntu16已经自带了，这里看了一下没有平常能用到的）

## 第8章 文件与文件系统的压缩

简单的来说，因为文件有相当多未填满空间，压缩就是把这些空间填满来使得整个文件的占用容量下降

常见压缩命令：

1. `gzip`（替代compress）：
   1. 可解开compress，zip和gzip的压缩文件
   2. 自己压缩的文件以.gz结尾
   3. 如果原本是文本文件，可以通过`zcat/zmore/zless`来分别以`cat/more/less`读取被压缩的文本
   4. 如果从文字压缩文件中找关键字可以通过`zgrep`
2. `bzip2`（替代gzip，提供更好的压缩比）：
   1. 压缩时间比gzip更久，时间换空间
   2. 生成.bz2结尾的压缩文件
   3. 有相应的`bzcat/bzmore/bzless`
3. `xz`（替代bzip2，更高的压缩比）
   1. 生成.xz结尾的压缩文件
   2. 对应的`xzcat/xzmore/xzless`
4. 打包命令`tar`
   1. 前面的压缩指令虽然可以对目录进行压缩，但本质是对所有文件分别进行压缩的操作
   2. `tar`的几个常用option：
      1. `-c`是compress压缩；`-t`是查看文件名；`-x`是解压
      2. `-z`通过gzip解压/压缩；`-j`通过bzip2；`-J`通过xz
      3. `-v`压缩/解压过程中显示正在处理的文件
      4. `-f`表示要被处理的文件，`-C`用在解压缩
      5. `-p`保留备份数据的原本权限和属性；`-P`保留绝对路径

其余的如同xfs文件系统以及光盘刻录，一个从未用过，一个已经过时，这里不再记录了

## 第9章 vim程序编辑器

很重要，虽然用的多，但还是仔细看看有没有遗漏的

1. vi三模式：
   1. 一般命令模式（command mode）
      1. 进入就是
      2. 可以删除字符或整行
      3. 可以使用复制黏贴
      4. [0或home]可回到这一行的最开始，[$或end]可回到这一行的最后
      5. `/word`和`?word`分别从光标的之下和之上找word的匹配
      6. 范围替换
         1. `:n1,n2s/word1/word2/g`从n1行到n2行(包括n1和n2)，所有word1替换成word2
         2. `:1,$s/word1/word2/gc`从第一到最后一行的替换，最后的c表示用户confirm是否替换(会逐行询问)
      7. 删除，复制和粘贴
         1. x等于del，X等于backspace
         2. `dd`剪切掉光标这一行，`ndd`剪切掉光标向下的n行
         3. `yy`复制所在的光标哪一行，`nyy`复制光标向下的n行，p和P把复制内容粘贴到光标下一行
      8. u恢复前一个操作，`ctrl+r`重做上一个操作
   2. 编辑模式（insert mode）
      1. 一般模式下无法编辑，按下`[i, I, o, O, a, A, r, R]`后进入（我一般I进入）
      2. Esc键退出编辑模式
   3. 命令行模式（command-line mode）
      1. 一般模式下输入`[:, /, ?]`任何进入
      2. 可以读取保存（最喜欢:wq了），批量替换，退出vi，显示行号等
      3. `:w!`强制写入，`:q!`强制退出不保存
      4. `:set nu`设置行号，`:set nonu`取消行号
2. vim会在编辑文件的目录建立一个以.filename.swap命名的暂时副本，如果vim因为不正常的原因中断（如一般命令下被ctrl+z中断），之后再打开就可以继续上次的进度
3. 之前也碰见过vim警告问题，Delete（D）可以删除之前的.swap文件，之后再创建一个新的.swap文件
4. 用`v`多行选中，`ctrl+v`矩形选中，选中后：y复制，d删除，p粘贴
5. vim+多个文件名打开多文件后：
   1. `:n`编辑下个文件
   2. `:N`编辑上个文件
   3. `:files`列出被这个vim开启的所有文件
6. vim多窗口（居然还这功能我是没想到的）
   1. `sp {filename}`打开俩文件
   2. `sp`直接sp可以打开同文件里的两个窗口
   3. 打开之后通过`ctrl+w+按键`来控制，`:q`退出光标在的page
7. vim关键字补全（佛了，这也有）
   1. `ctrl+x -> ctrl+n`使用在文件中的文本进行关键字补全
   2. `ctrl+x -> ctrl+n`使用在当前目录内的文件名进行补全
   3. `ctrl+x -> ctrl+o`使用扩展名（vim内置）进行补全

## 第10章 认识与学习BASH

1. 可以通过`type [-tpa] name`来看command是内部命令（bulletin），别名（alias）还是外部命令（file）

2. 变量的使用和设置：

   1. echo可以输出变量，如`echo ${PATH}`，man看了一下，本质是展示一行文本

   2. 变量可以直接通过`var=abc`来定义，但注意以下：

      1. 变量两边不能有空格
      2. 变量名称**只能是英文和数字，且不可以以数字开头**
      3. 双引号内使用$可以保持原本的特性（类似于py里的插入）
      4. 单引号内就是纯文本（内部可用转义符）

   3. 子程序在继承父进程时只能继承环境变量，想使用父进程自定义变量使用`export PATH`

   4. 系统定义的变量一般大写，自定义小写

   5. 取消变量定义用`unset var`

   6. 反单引号`` `的意思是先执行内部的命令，比如

      ```shell
      ls -l `name` 
      ls -l ${name}
      ```

      以上俩命令本质是一样的

3. `env`命令可以看到所有的环境变量，`set`可以看所有包括自定义的变量，其中比较重要的几个变量

   1. PS1（P323）是命令提示字符
   2. $有关于本shell的PID，可用`echo $$`查看
   3. ?:是关于上个执行命令的返回值，一般成功执行返回值都是0

4. 可以用`read`指令来读取键盘或文件中的变量

5. `declare`默认把所有变量都print出来，可以`[-aixr]`来限定转换成什么类型，变量类型默认字符串

6. `ulimit`限制开启的资源总量

7. 变量内容的删除，取代与替换：

   1. 删除
      1. 书上例子`${变量#关键字} -> echo ${path#/*local/bin:}`会把**最短的匹配这个模式的字符串**删掉，*这里是通配符。##是把**最长的匹配这模式的字符串**删掉
      2. `${变量%关键字}`%就是从后向前匹配，找最短匹配这个模式字符串删掉，%%找最长的
   2. 替换：
      1. `${变量/旧字符串/新字符串}`把第一个旧字符串替换掉
      2. `${变量//旧字符串/新字符串}`把所有的旧字符串替换掉
      3. `${name-内容}`可以做到通过`-`，如果name被设置就无事发生，如果没被设置就使用内容

8. 通过`history`打印出`~/.bash_history`的内容，依序记录，但无法记录时间

9. Bash命令的执行顺序，

   1. 以绝对/相对路径执行命令
   2. 由alias找到命令
   3. 由bash内置的bulletin命令执行
   4. 通过$PATH顺序找到的第一个指令执行

10. bash的环境配置文件

    1. login shell指取得bash需要完整的登录流程，而non-login shell不需要重复操作（比如子进程）
    2. login shell会读两个文件：
       1. /etc/profile：系统整体设置，不要更改
       2. ~/.bash_profile或~/.bash_login或~/.profile，用户个人的设置，可以修改，这三个文件有先后顺序，但bash只读取其中一个，其余两个不论存在与否都不再读取
       3. 书上说~/.bash_profile会先找~/.bashrc(但ubuntu16里压根没有profile，直接就是bashrc哈哈哈哈)
    3. `source`命令读取环境配置文件，比如我就常用`source ~/.bashrc`
    4. `~/.bash_logout`记录了当注销bash后，系统还会帮我做什么操作

11. `stty`指令可以帮助查看**当前的按键内容**

12. 通配符：*表示有0或无穷多个任意字符，？表示一个任意字符，[]（如[abcd]）表示一定有一个括号内的字符，[-]（如[0-9]）表示**编码顺序内的所有字符**，[^]（如【^abc】）表示除了a，b，c以外的任意一个

13. 数据流重定向：

    1. 就像C++里，输入符号为<或<<，输出符号为>或>>，stderr为2>或2>>
    2. 比如`ls -l >> testFile`就会把原本输出到terminal的数据都输出到testFile里，如果testFile不存在也会自动创建一个（书上说会覆盖，但我多试了几次后发现ubuntu16并不会覆盖，而是直接在先用文件后面接着写）
    3. 如果想直接丢弃，可以使用黑洞设备`dev/null`如`2>> /dev/null`
    4. 如果正确和错误的信息都想写到同一个文件，可以用`2>&1`或`&>`

14. 管道命令pipe（也就是`|`符号）

    1. 管道仅能处理stdout，stderr会被忽略
    2. 必须接受来自前一个命令的stdout作为stdin继续处理才行（所以叫管道，一环扣一环）
    3. 选取命令`cut`：
       1. `cut -d '分隔字符' -f fields`，其中'分隔字符'就是类似java split方法的字符，fields就是具体取用分割后的哪几块显示
       2. `-c number`表示以number为单位取出固定的字符串区间
    4. 选取命令`grep`：
       1. cut是将某行信息中我们想要的部分分割拿出来，grep是分析一行信息，如果匹配就把整行拿出来
       2. 底层是正则，很多语法见P352
    5. 排序命令`sort`:
       1. 啥都不加就是每行为一个元素，然后比较从小到大排序
       2. 其他的见P353
    6. 排序命令`uniq`：
       1. 把重复的数据（同样按行）仅列出一个显示（底层应该是hash set）
       2. `-c`进行计数，`-i`忽略大小写字母的不同
    7. 排序命令`wc`：
       1. 计算文件中的行/word/字符
       2. 分别用`-l`行；`-w`word；`-m`字符数
    8. 双重重定向`tee`：
       1. 把数据流既给文件又给screen
       2. 用法`tee filename`，如果不加`-a`就会覆盖（这次是真的会覆盖）
    9. 字符转换命令`tr`：
       1. 

